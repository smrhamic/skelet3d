Implementation was done in NetBeans IDE 8.0.1 \cite[netbeans], a free open source development environment mostly focused on Java.

For development purposes, a local Glassfish 4.1 server was installed and integrated into NetBeans for easy “on save” deployment in real time.

\sec Data Model

The first step of implementation was creating a data model. As mentioned in previous chapter, our business objects will be persisted in a relational database. Images and models will also be using a file system to save their possibly large binary data.

\secc Setting Up a Local Database

Glassfish server comes with a pre-installed Java DB and NetBeans made it easy to setup a connection.

The only pitfall lay in Java’s default security policy, which did not allow access to Java DB on standard port 1527. See StackOverflow question \cite[so_java_permits] for details.

\secc Creating Tables

I used the ER diagram from design phase to generate an SQL script for table creation. I had to make syntactic changes because generated script was in MySQL, which differs from Java DB syntax. After solving all syntactic issues, all tables were successfully created. The working script was saved for later use.

\secc Generating Entities

NetBeans offers a feature for generating Entity classes from a registered database. I gladly used this feature to generate properly annotated, JPA-compatible classes for all Entities.

In later stages of development, Entities returned to being thin data-holding classes without much logic of their own. Other than several simple changes (see below) and removing a small amount of generated ballast, they were largely the same as the originally generated ones.

\secc PageComponent Abstract Class

Page components, namely {\tt HeadlineComponent}, {\tt TextComponent}, {\tt ImageComponent} and {\tt ModelComponent} share 
this common ancestror.

It implements {\tt Comparable<PageComponent>} and a {\tt compareTo(PageComponent c)} method which sorts components by their order. It also defines an abstract getter and setter for {\tt compOrder} and a getter for {\tt componentType}, which is to return a string representation of component type such as “text” or “image”.

\sec Service Layer

Services are in charge of business logic, in case of our Atlas mostly handling persistence and relations between business objects. All service classes are EJBs to allow container-managed transactions. This is important, because otherwise all transactions need to be handled manually and JPA {\tt EntityManager} cannot be simply injected.

\secc BasicService

All service classes inherit from this common ancestor. It is a generic class {\tt BasicService<E, PK>} where {\tt E} is an Entity class and PK is the primary key class of the Entity.

It injects an {\tt EntityManager} using the {\tt @PersistenceContext} annotation, leaving it to the descendant services to make sure this injection is possible (simply being EJB fulfills this requirement) or creating their own {\tt EntityManager}.

It provides a {\tt BasicService(Class<E> entityType)} constructor, which takes the Entity class as a parameter. This might seem unnecessary when using generic classes, but I found no better way to access the Entity’s type in method calls other than keeping a {\tt type : Class<E>} property and assigning it explicitly in the constructor.

{\tt BasicService} implements 5 default CRUD methods:

\begitems

*{\tt find(PK key) : E}

finds an Entity by its primary key, using {\tt EntityManager}’s {\tt find(…)} method.

*{\tt findAll() : List<E>}

finds all Entities of a type {E} using a simple JPQL query on {\tt EntityManager}.

*{\tt save(E entity)}

persist a previously unpersisted Entity using {\tt EntityManager}’s {\tt persist(…)} method.

*{\tt update(E entity)}

updates a persisted Entity using {\tt EntityManager}’s {\tt merge(…)} method.

*{\tt delete(E entity)}

deletes a persisted Entity using {\tt EntityManager}’s {\tt remove(…)} method. In order for the deletion to work, it first needs to get a managed instance of the entity by referencing the output of {\tt merge(entity)}.

\enditems

\secc Common Traits and LanguageService Example

The inheriting services implement different methods, but follow certain similar patterns. They are {\tt @Stateless} EJBs, they are related to an Entity class and have a no-argument constructor which calls {\tt BasicService(entityType)}.

Below you can see the actual code of {\tt LanguageService}, one of the simplest service classes in our application. Note how it extends {\tt BasicService}, calls its super-class’s constructor and uses inherited {\tt Entity Manager em} to perform operations related to persistence (in this case it executes “find” queries). Other methods such as {\tt findAll()} or {\tt save(Language lang)} are inherited from {\tt BasicService} and not overridden, since their default implementation is sufficient for {\tt Language}.

\vfil \break

\begtt

@Stateless
public class LanguageService extends BasicService<Language, Integer> {

    /**
     * Constructs a LanguageService.
     */
    public LanguageService() {
        super(Language.class);
    }
    
    /**
     * Finds the default persisted Language.
     *
     * @return First result of a "default" flagged Language; or null.
     */
    public Language findDefaultLanguage() {
        // get default flagged language
        try {
            TypedQuery<Language> query = em.createQuery(
                    "SELECT l FROM Language l "
                            + "WHERE l.defaultLang = TRUE",
                    Language.class);
            return query.getSingleResult();
        } catch (NoResultException e) {
            // if none, null
            return null;
        }
    }
    
    /**
     * Finds persisted Language by ISO short code.
     *
     * @param code ISO code to search for. Examples: "en", "cs"
     * @return Language matching the ISO code, null if no match.
     */
    public Language findLanguageByISO639(String code) {
        // get language with matching code
        try {
            TypedQuery<Language> query = em.createQuery(
                    "SELECT l FROM Language l "
                            + "WHERE l.short1 = :code",
                    Language.class);
            return query.setParameter("code", code).getSingleResult();
        } catch (NoResultException e) {
            // if none, null
            return null;
        }
    }
}
\endtt

\vfil \break

\secc UserService

\begitems

*{\tt login(String login, String pass) : User}

Validates login credentials, uses a JPQL query and either returns a matching user or {\tt null}.

\enditems

Unfortunately, advanced user management is not implemented as of yet. One of the next steps is making the stored passwords safer by hashing them with salt. The database was created with this in mind, so the implementation should be easy.

\secc CategoryService

\begitems

*{\tt findRootCategories() : List<Category>}

Uses a JPQL query which returns all categories without a parent (top-level categories).

*{\tt createCategoryView(Category cat, Language lang) : CategoryView}

Creates a {\tt CategoryView} based on {\tt cat} argument and queried {\tt CategoryInfo}. It also calculates the number of pages.

*{\tt countNumberOfPages(Category cat, Language lang, boolean publishedOnly) : int}

Recursively counts the number of pages inside category and its child categories. The recursion can be costly, but this will hopefully prove insignificant due to a low number of categories in the tree. If this ever becomes an issue, the solution is keeping a “numPages” property in the database. This would mean updating all ancestor categories whenever a page is created / removed, but it would speed up regular browsing. It is worth noting that thanks to JPA, this recursion accesses objects in memory and does not cause database hits.

\enditems

\secc PageService

\begitems

*{\tt createNewPage(int categoryId) : Page}

Creates a blank, unpublished {\tt Page} including {\tt PageContent}s for all language variants. Persists all this and also updates the parent category to recognize the new page.

*{\tt createPageView(Page page, Language lang) : PageView}

Creates a {\tt PageView} based on {\tt page} argument and queried {\tt PageContent}.

\enditems

It is also worth noting that this service overrides {\tt delete(page)} and updates the parent category’s page collection, which would otherwise still include a reference to the deleted page.

\secc PageContentService

\begitems

*{\tt updateWithComponents(pageContent, List<PageComponent> components)}

Replaces all {\tt PageComponent}s with new ones (passed in argument). Iterates through the {\tt components} collection and adds each component to {\tt PageContent}’s respective collection (text, image…). Changes are persisted using inherited {\tt update(pageContent)}.

\enditems

\secc ModelService

\begitems

*{\tt uploadModel(String name, Part modelFile)}

Creates and persists a {\tt Model} entity and also saves the uploaded file to server. The filename is taken from uploaded file, but non-standard characters are replaced and in case of duplicity, numbers are appended. Models are persisted in a designated folder which the server recognizes as an “alternate document root” for easy access on the website.

*{\tt deleteModel(Model model)}

Calls the default {\tt delete(model)} and also deletes the model’s binary file.

*{\tt isUsed(Model model) : boolean}

Runs a JPQL query to find out whether this model is used in any component.

\enditems

\secc ImageService

Works very much like {\tt ModelService} but with {\tt Image} entities and image files.

\secc LabelService

\begitems

*{\tt createLabelViews(Model model, Language lang) : List<LabelView>}

Creates all {\tt LabelView}s for a model in given language using a JPQL query. JPQL lets us create instances of any class if we map the query results to a constructor. That feature was used here so that the “JOIN” query returns a list of {\tt LabelView}s directly.

*{\tt updateLabelsFromJSON(String json, Model model, Language lang)}

Labels are edited in client side JavaScript and changes to be saved are sent to the server as a JSON string. The string represents an array of {\tt LabelViews}. This method parses the string using Google’s open source library GSON \cite[gson]. Then it treats each {\tt LabelView} appropriately to its {\tt action} property and either creates, deletes or removes a {\tt Label} including its {\tt LabelContent}. {\it  Note: It could be argued that the conversion from JSON to LabelView objects should be done in Controller rather than the Service layer.}

\enditems

\secc LabelContentService

This service does not implement any new methods, but overrides {\tt save(labelContent)} and {\tt update(labelContent)} to escape all textual data before persisting. This is necessary, because labels are displayed in JavaScript, which easily breaks if unsafe characters are present.  This is achieved by {\tt StringEscapeUtils.escapeJavaScript(text)}, which is a method of the Apache Commons Lang \cite[apache_commons] library.

\sec Backing Beans

Backing beans are the next layer of our application, one step closer to the client. In our application they are called Controllers (although the real Controller is in fact a {\tt FacesServlet} working behind the scenes).

Each backing bean belongs to a View component (a reusable piece of HTML), provides content from the Model and methods for manipulating it.

Backing beans are annotated with their “scope”, which defines the bean’s lifespan. Most beans are either {\tt @ViewScoped}, which means they’re recreated when a new page is displayed, or {\tt @SessionScoped}, which means the bean lives and holds its state as long as a session with a client is maintained.

It is important to note that proper annotation and import is required, for example {\tt @SessionScoped @Named("loginController")}. The correct imports would be {\tt javax.faces.view.ViewScoped} and {\tt javax.inject.Named}. Some older tutorials use {\tt @ManagedBean} annotation and different imports, which is an outdated approach and CDI annotations mentioned above should be used instead. If you happen to mix the wrong annotations and imports, your code will break.

The typical life cycle of a backing bean is this:

\begitems

*Initialization, when relevant data is fetched from Model

*Providing methods and data for View

*End of life (depends on scope)

\enditems

Most beans’ initialization methods are called using {\tt @PostConstruct} annotation, but several need an attribute from View (typically page ID) to initialize properly. This is realized by Facelets, which calls the {\tt init(…)} method when bound properties are already set. We tell Facelets to do this by setting {\tt f:viewAction} and {\tt f:viewParam} tags.

Implementing “bound properties” is really easy in a CDI annotated bean. All you have to do is have a private field with public getter/setter and the property is bound. It can then be accessed in a Facelets page like {\tt value=\char`\"\#\char`\{loginController.userName\char`\}\char`\"}.

Action methods are public methods which can be called from Facelets pages such as {\tt action=\char`\"\#\char`\{loginController.login()\char`\}\char`\"}. These methods can have parameters and should return a {\tt String} (redirection rule) or {\tt void}. They are sometimes called within Ajax context and sometimes not. For this reason many action methods in our application specify a {\tt boolean ajax} parameter which determines whether the page should be reloaded at the end of the method run. If {\tt ajax} is {\tt true}, returned redirection string is {\tt null} so that Ajax can take care of the view update.

\secc BasicController

This is an abstract class which backing beans can inherit from.

Backing beans do not have too much in common, so this ancestor is not really necessary. It was introduced in later stages of development to make the other backing beans’ code a little neater and easier to read.

It implements methods for displaying messages in the View. Messages are passed as a string argument and set as {\tt FacesMessage} in current {\tt FacesContext}. Because the messages can be (and typically will be) localized strings from a resource bundle, these methods evaluate their string input as an EL expression. That way, simple strings are displayed directly, but EL expressions can be used just like they would be used in a Facelets page.

Displaying messages is a common task especially during content editing. This originally created chunks of repeated, verbose code. Implementing a common ancestor reduced these chunks to one-line method calls, which look like this for localized messages:

 {\tt showWarning(\char`\"\#\char`\{messages.noRights\char`\}\char`\")}.

\secc LanguageController

This session bean is initialized post-construct. It communicates with Model through {\tt LanguageService}. During initialization, it takes the preferred locale from client browser and either assigns a matching language or resorts to default language if no match is found. It also loads all supported languages.

During its life it holds the current language, current locale, a list of available languages and provides a method for switching languages, which simply sets the {\tt currentLanguage}, locale and reloads the page.

Many other backing beans refer to this one to find out what language should be used and it is their responsibility to choose the appropriate content, not {\tt LanguageController}’s.

\secc LoginController

This is the second of our two session beans and is also initialized post-construct. It communicates with Model through {\tt UserService}. During initialization, it sets current user to {\tt null} and user privileges to {\tt false}.

During its life it holds the current user, a flag denoting “edit rights”, properties bound to login input fields and provides methods for login and logout.

Again, many other backing beans refer to this one to confirm user rights and it’s their responsibility to take appropriate actions, not {\tt LoginManager}’s.

\secc PathController

This request scoped backing bean provides a path to current page or category, simply put a page’s parent, grandparent etc. all the way to a root category. It is initialized by Facelets and requires an {\tt isPage} argument (to define whether it’s working with a page or category) and the ID of current page/category (which is in fact a bound property, although we could have made it a method argument).

It uses {\tt PageService} or {\tt CategoryService} to find the page/category by ID and then adds its ancestors in a loop: While “current” page has a parent, add it to path and make it “current”. The path is a list of {\tt CategoryView}.

\secc CategoryController

This view scoped backing bean is initialized by Facelets so it can access current category ID (bound property) during initialization. It provides content of current category (including “views” of its children, non-recursive) and methods for managing pages in this category. Management of categories as such has not been implemented yet. It also provides root categories instead of children in case current category is unset. It uses both {\tt CategoryService} and {\tt PageService}.

Methods {\tt addNewPage(…)} and {\tt deletePage(…)} check user rights, call corresponding service methods, display a message and reload the page (or not if Ajax is used). {\tt goEditPage(…)} is just a redirect which checks user rights.

\secc PageController

This view scoped backing bean is initialized by Facelets so it can access current page ID (bound property) during initialization. It provides content of the page and methods for editing the page including labels of the page’s 3D model. It uses {\tt PageService}, {\tt PageContentService} and {\tt LabelService} to communicate with Model.

Page components are fetched during initialization and sorted. Once sorted, their {\tt compOrder} is set to increment by one (0, 1, 2 .. n) to allow easy manipulation of component order during editing.

3D models get a bit of special treatment because of the need to handle label editing. In current implementation only one 3D model is allowed in a page (if more are present for some reason, only first one is processed).  Thanks to {\tt PageComponent}’s interface, all components are held in a single collection and the same methods are used to manipulate all of them.

During page editing, changes are held in this backing bean and only uploaded to database when saved using {\tt updatePage(…)}, which persists current page and its component collection. Because of this, all editing requests are required to update the page using Ajax; otherwise the view, this bean and all unsaved changes would be reset.

{\tt addComponent(String type)} method is implemented as a switch which pre-fills a default component of given type and places is at the end of collection. Methods for changing component order swap two components in the collection and adjust their {\tt compOrder} appropriately. Components are removed simply by removing them from the collection. No methods for editing the content of individual components are needed, because being managed properties, they can be edited directly in Facelets pages.

A method for persisting changes of 3D model’s labels was implemented. It passes a JSON String generated by JavaScript to {\tt LabelService}, where all the magic happens.

\secc ModelController

Note that this takes care of a “Model Manager” page, not displaying models in pages (backing beans are related to a particular view/page rather than Entities). This view scoped backing bean is initialized post-construct and fetches all 3D models from {\tt ModelService} and sorts them alphabetically.

In addition to more standard properties, a {\tt Part modelFile} is bound. It is used to upload files into the system and {\tt Part} is the object generated by Facelets’ upload file component. Methods to upload, edit (meta-data, not geometry) and delete models check user rights and call corresponding service methods. Deletion is preceded by making sure the model is not used in a component.

\secc ImageController

This bean is analogous to {\tt ModelController}, but works with images.

\secc Converters

{\tt ModelConverter} and {\tt ImageConverter} classes implementing {\tt Converter} interface were introduced to allow displaying Models and Images in drop-down lists. Implementation is trivial and maps Entity objects to their IDs.

\sec View -- Facelets and HTML

Since we are creating a web application and using JSF, the View is realized by a series of HTML (in fact, XHTML) pages generated by JSF’s presentation technology. In our case, that technology would be Facelets.

Facelets is a page declaration language which can be used for creating templates, components and much more. It allows effective work with XHTML and uses Expression Language (EL) to access methods and properties of managed beans. It supports several tag libraries for generating UI components, templating etc. For more details see \cite[facelets].

\secc Templating

All our pages follow a single basic template located at {\tt webapp/template/basic.xhtml}. A template defines a basic skeleton of the page including interchangeable components placed in their respective locations.

This is an example of inserting our main content component in the template and choosing {\tt welcome.xhtml} as the default component (which is used unless specifically overwritten):

\begtt

<ui:insert name=”content”>
        <ui:include src="../components/welcome.xhtml" />
</ui:insert>

\endtt

And this is how we would use this template in an actual page that uses {\tt content\_page.xhtml} as its main content (assuming other components stay default):

\begtt

<ui:composition template="/template/basic.xhtml">
        <ui:define name=”content”>
                <ui:include src="components/content_page.xhtml"/>
        </ui:define>
</ui:composition>

\endtt

Using such a template lets us reuse components and if the defaults are set correctly, we only need to define one or two components per page. This practice reduces writing a new page into writing a content component. It makes the pages easily maintainable, as changing a component affects all pages that are using it without disturbing the rest of the layout.



