In this chapter we talk about the implementation of all parts of the application, including the database, server logic in Java and 3D viewer in JavaScript. We also briefly describe the application’s deployment.

Most (but not all) of the application was implemented and is ready for real use. As of yet unimplemented are the administration tools for managing registered users’ accounts.

Implementation was done in NetBeans \glref{IDE} 8.0.1 \cite[netbeans], a free open source development environment mostly focused on Java. All final source code can be seen on attached CD.

For development purposes, a local Glassfish 4.1 server was installed and integrated into NetBeans for easy “on save” deployment in real time.

\sec Data Model

The first step of implementation was creating a data model. As mentioned in previous chapter, our business objects will be persisted in a relational database. Images and models will also be using a file system to save their possibly large binary data.

\secc Setting Up a Local Database

Glassfish server comes with a pre-installed Java \glref{DB} and NetBeans made it easy to setup a connection.

The only pitfall lay in Java’s default security policy, which did not allow access to Java \glref{DB} on standard port 1527. See StackOverflow question \cite[so_java_permits] for details.

\label[impl_tables]
\secc Creating Tables

I used the \glref{ER} diagram from design phase to generate an \glref{SQL} script for table creation. I had to make syntactic changes because generated script was in MySQL, which differs from Java \glref{DB} syntax. After solving all syntactic issues, all tables were successfully created. The working script was saved for later use.

\secc Generating Entities

NetBeans offers a feature for generating Entity classes from a registered database. I gladly used this feature to generate properly annotated, \glref{JPA}-compatible classes for all Entities.

In later stages of development, Entities returned to being thin data-holding classes without much logic of their own. Other than several simple changes (see below) and removing a small amount of generated ballast, they were largely the same as the originally generated ones.

\secc PageComponent Abstract Class

Page components, namely {\tt HeadlineComponent}, {\tt TextComponent}, {\tt ImageComponent} and {\tt ModelComponent} share 
this common ancestror.

It implements {\tt Comparable<PageComponent>} and a {\tt compareTo(PageComponent c)} method which sorts components by their order. It also defines an abstract getter and setter for {\tt compOrder} and a getter for {\tt componentType}, which is to return a string representation of component type such as “text” or “image”.

\sec Service Layer

Services are in charge of business logic, in case of our Atlas mostly handling persistence and relations between business objects. All service classes are \glref{EJB}s ({\tt @Stateless}) to allow container-managed transactions. This is important, because otherwise all transactions need to be handled manually and \glref{JPA} {\tt EntityManager} cannot be simply injected.

\secc BasicService

All service classes inherit from this common ancestor. It is a generic class {\tt BasicService<E, PK>} where {\tt E} is an Entity class and {\tt PK} is the primary key class of the Entity.

It injects an {\tt EntityManager} using the {\tt @PersistenceContext} annotation, leaving it to the descendant services to make sure this injection is possible (simply being \glref{EJB} fulfills this requirement) or creating their own {\tt EntityManager}.

It provides a {\tt BasicService(Class<E> entityType)} constructor, which takes the Entity class as a parameter. This might seem unnecessary when using generic classes, but I found no better way to access the Entity’s type in method calls other than keeping a {\tt type : Class<E>} property and assigning it explicitly in the constructor. Inheriting classes then implement a no-argument constructor which calls {\tt BasicService(entityType)}.

{\tt BasicService} implements 5 default \glref{CRUD} methods:

\begitems

*{\tt find(PK key) : E}

finds an Entity by its primary key, using {\tt EntityManager}’s {\tt find(…)} method.

*{\tt findAll() : List<E>}

finds all Entities of a type {E} using a simple \glref{JPQL} query on {\tt EntityManager}.

*{\tt save(E entity)}

persist a previously unpersisted Entity using {\tt EntityManager}’s {\tt persist(…)} method.

*{\tt update(E entity)}

updates a persisted Entity using {\tt EntityManager}’s {\tt merge(…)} method.

*{\tt delete(E entity)}

deletes a persisted Entity using {\tt EntityManager}’s {\tt remove(…)} method. In order for the deletion to work, it first needs to get a managed instance of the entity by referencing the output of {\tt merge(entity)}.

\enditems

\secc LanguageService -- Example Service

Below you can see the actual code of {\tt LanguageService}, one of the simplest service classes in our application. Note how it extends {\tt BasicService}, calls its super-class’s constructor and uses inherited {\tt Entity Manager em} to perform operations related to persistence (in this case it executes “find” queries). Other methods such as {\tt findAll()} or {\tt save(Language lang)} are inherited from {\tt BasicService} and not overridden, since their default implementation is sufficient for {\tt Language}.

\vfil \break

\begtt

@Stateless
public class LanguageService extends BasicService<Language, Integer> {

    /**
     * Constructs a LanguageService.
     */
    public LanguageService() {
        super(Language.class);
    }
    
    /**
     * Finds the default persisted Language.
     *
     * @return First result of a "default" flagged Language; or null.
     */
    public Language findDefaultLanguage() {
        // get default flagged language
        try {
            TypedQuery<Language> query = em.createQuery(
                    "SELECT l FROM Language l "
                            + "WHERE l.defaultLang = TRUE",
                    Language.class);
            return query.getSingleResult();
        } catch (NoResultException e) {
            // if none, null
            return null;
        }
    }
    
    /**
     * Finds persisted Language by ISO short code.
     *
     * @param code ISO code to search for. Examples: "en", "cs"
     * @return Language matching the ISO code, null if no match.
     */
    public Language findLanguageByISO639(String code) {
        // get language with matching code
        try {
            TypedQuery<Language> query = em.createQuery(
                    "SELECT l FROM Language l "
                            + "WHERE l.short1 = :code",
                    Language.class);
            return query.setParameter("code", code).getSingleResult();
        } catch (NoResultException e) {
            // if none, null
            return null;
        }
    }
}
\endtt

\vfil \break

\secc UserService

\begitems

*{\tt login(String login, String pass) : User}

Validates login credentials, uses a \glref{JPQL} query and either returns a matching user or {\tt null}.

\enditems

Unfortunately, advanced user management is not implemented as of yet.

Passwords are hashed using \glref{SHA}-256 algorithm and salted by appending a randomized string.

\secc CategoryService

\begitems

*{\tt findRootCategories() : List<Category>}

Uses a \glref{JPQL} query which returns all categories without a parent (top-level categories).

*{\tt createCategoryView(Category cat, Language lang) : CategoryView}

Creates a {\tt CategoryView} based on {\tt cat} argument and queried {\tt CategoryInfo}. It also calculates the number of pages.

*{\tt countNumberOfPages(Category cat, Language lang, boolean publishedOnly) : int}

Recursively counts the number of pages inside category and its child categories. The recursion can be costly, but this will hopefully prove insignificant due to a low number of categories in the tree. If this ever becomes an issue, the solution is keeping a “numPages” property in the database. This would mean updating all ancestor categories whenever a page is created / removed, but it would speed up regular browsing. It is worth noting that thanks to \glref{JPA}, this recursion accesses objects in memory and does not cause database hits.

\enditems

\secc PageService

\begitems

*{\tt createNewPage(int categoryId) : Page}

Creates a blank, unpublished {\tt Page} including {\tt PageContent}s for all language variants. Persists all this and also updates the parent category to recognize the new page.

*{\tt createPageView(Page page, Language lang) : PageView}

Creates a {\tt PageView} based on {\tt page} argument and queried {\tt PageContent}.

*{\tt searchByName(String searchTerm, Language lang) : List<Page>}

Searches for pages whose name (localized or Latin) contains the {\tt searchTerm} as substring. The matching is case insensitive.

\enditems

It is also worth noting that this service overrides {\tt delete(page)} and updates the parent category’s page collection, which would otherwise still include a reference to the deleted page.

\secc PageContentService

\begitems

*{\tt updateWithComponents(pageContent, List<PageComponent> components)}

Replaces all {\tt PageComponent}s with new ones (passed in argument). Iterates through the {\tt components} collection and adds each component to {\tt PageContent}’s respective collection (text, image…). Changes are persisted using inherited {\tt update(pageContent)}.

\enditems

\secc ModelService

\begitems

*{\tt uploadModel(String name, Part modelFile)}

Creates and persists a {\tt Model} entity and also saves the uploaded file to server. The filename is taken from uploaded file, but non-standard characters are replaced and in case of duplicity, numbers are appended. Models are persisted in a designated folder which the server recognizes as an “alternate document root” for easy access on the website.

*{\tt deleteModel(Model model)}

Calls the default {\tt delete(model)} and also deletes the model’s binary file.

*{\tt isUsed(Model model) : boolean}

Runs a \glref{JPQL} query to find out whether this model is used in any component.

\enditems

\secc ImageService

Works very much like {\tt ModelService} but with {\tt Image} entities and image files.

\secc LabelService

\begitems

*{\tt createLabelViews(Model model, Language lang) : List<LabelView>}

Creates all {\tt LabelView}s for a model in given language using a \glref{JPQL} query. \glref{JPQL} lets us create instances of any class if we map the query results to a constructor. That feature was used here so that the “JOIN” query returns a list of {\tt LabelView}s directly.

*{\tt updateLabelsFromJSON(String json, Model model, Language lang)}

Labels are edited in client side JavaScript and changes to be saved are sent to the server as a \glref{JSON} string. The string represents an array of {\tt LabelViews}. This method parses the string using Google’s open source library GSON \cite[gson]. Then it treats each {\tt LabelView} appropriately to its {\tt action} property and either creates, deletes or removes a {\tt Label} including its {\tt LabelContent}. {\it  Note: It could be argued that the conversion from \glref{JSON} to LabelView objects should be done in Controller rather than the Service layer.}

\enditems

\secc LabelContentService

This service does not implement any new methods, but overrides {\tt save(labelContent)} and {\tt update(labelContent)} to escape all textual data before persisting. This is necessary, because labels are displayed in JavaScript, which easily breaks if unsafe characters are present.  This is achieved by {\tt StringEscapeUtils.escapeJavaScript(text)}, which is a method of the Apache Commons Lang \cite[apache_commons] library.

\sec Backing Beans

Backing beans are the next layer of our application, one step closer to the client. In our application they are called Controllers (although the real Controller is in fact a {\tt FacesServlet} working behind the scenes).

Each backing bean belongs to a View component (a reusable piece of \glref{HTML}), provides content from the Model and methods for manipulating it.

Backing beans are annotated with their “scope”, which defines the bean’s lifespan. Most beans are either {\tt @ViewScoped}, which means they’re recreated when a new page is displayed, or {\tt @SessionScoped}, which means the bean lives and holds its state as long as a session with a client is maintained.

It is important to note that proper annotation and import is required, for example {\tt @SessionScoped @Named("loginController")}. The correct imports would be {\tt javax.faces.view.ViewScoped} and {\tt javax.inject.Named}. Some older tutorials use {\tt @ManagedBean} annotation and different imports, which is an outdated approach and \glref{CDI} annotations mentioned above should be used instead. If you happen to mix the wrong annotations and imports, your code will break.

The typical life cycle of a backing bean is this:

\begitems

*Initialization, when relevant data is fetched from Model

*Providing methods and data for View

*End of life (depends on scope)

\enditems

Most beans’ initialization methods are called using {\tt @PostConstruct} annotation, but several need an attribute from View (typically page ID) to initialize properly. This is realized by Facelets, which calls the {\tt init(…)} method when bound properties are already set. We tell Facelets to do this by setting {\tt f:viewAction} and {\tt f:viewParam} tags.

Implementing “bound properties” is really easy in a \glref{CDI} annotated bean. All you have to do is have a private field with public getter/setter and the property is bound. It can then be accessed in a Facelets page like {\tt value=\char`\"\#\char`\{loginController.userName\char`\}\char`\"}.

Action methods are public methods which can be called from Facelets pages such as {\tt action=\char`\"\#\char`\{loginController.login()\char`\}\char`\"}. These methods can have parameters and should return a {\tt String} (redirection rule) or {\tt void}. They are sometimes called within Ajax context and sometimes not. For this reason many action methods in our application specify a {\tt boolean ajax} parameter which determines whether the page should be reloaded at the end of the method run. If {\tt ajax} is {\tt true}, returned redirection string is {\tt null} so that Ajax can take care of the view update.

\secc BasicController

This is an abstract class which backing beans can inherit from.

Backing beans do not have too much in common, so this ancestor is not really necessary. It was introduced in later stages of development to make the other backing beans’ code a little neater and easier to read.

It implements methods for displaying messages in the View. Messages are passed as a string argument and set as {\tt FacesMessage} in current {\tt FacesContext}. Because the messages can be (and typically will be) localized strings from a resource bundle, these methods evaluate their string input as an \glref{EL} expression. That way, simple strings are displayed directly, but \glref{EL} expressions can be used just like they would be used in a Facelets page.

Displaying messages is a common task especially during content editing. This originally created chunks of repeated, verbose code. Implementing a common ancestor reduced these chunks to one-line method calls, which look like this for localized messages:

 {\tt showWarning(\char`\"\#\char`\{messages.noRights\char`\}\char`\")}.

\secc LanguageController

This session bean is initialized post-construct. It communicates with Model through {\tt LanguageService}. During initialization, it takes the preferred locale from client browser and either assigns a matching language or resorts to default language if no match is found. It also loads all supported languages.

During its life it holds the current language, current locale, a list of available languages and provides a method for switching languages, which simply sets the {\tt currentLanguage}, locale and reloads the page.

Many other backing beans refer to this one to find out what language should be used and it is their responsibility to choose the appropriate content, not {\tt LanguageController}’s.

\secc LoginController

This is the second of our two session beans and is also initialized post-construct. It communicates with Model through {\tt UserService}. During initialization, it sets current user to {\tt null} and user privileges to {\tt false}.

During its life it holds the current user, a flag denoting “edit rights”, properties bound to login input fields and provides methods for login and logout.

Again, many other backing beans refer to this one to confirm user rights and it’s their responsibility to take appropriate actions, not {\tt LoginManager}’s.

\secc PathController

This request scoped backing bean provides a path to current page or category, simply put a page’s parent, grandparent etc. all the way to a root category. It is initialized by Facelets and requires an {\tt isPage} argument (to define whether it’s working with a page or category) and the ID of current page/category (which is in fact a bound property, although we could have made it a method argument).

It uses {\tt PageService} or {\tt CategoryService} to find the page/category by ID and then adds its ancestors in a loop: While “current” page has a parent, add it to path and make it “current”. The path is a list of {\tt CategoryView}.

\secc CategoryController

This view scoped backing bean is initialized by Facelets so it can access current category ID (bound property) during initialization. It provides content of current category (including “views” of its children, non-recursive) and methods for managing pages in this category. Management of categories as such has not been implemented yet. It also provides root categories instead of children in case current category is unset. It uses both {\tt CategoryService} and {\tt PageService}.

Methods {\tt addNewPage(…)} and {\tt deletePage(…)} check user rights, call corresponding service methods, display a message and reload the page (or not if Ajax is used). {\tt goEditPage(…)} is just a redirect which checks user rights.

\secc SearchController

This view scoped backing bean is initialized by Facelets so it can access its "search term", which is passed as an URL parameter and bound to a property. It provides a list of all pages matching the search term using {\tt PageService}'s {\tt searchByName(...)}.

\secc PageController

This view scoped backing bean is initialized by Facelets so it can access current page ID (bound property) during initialization. It provides content of the page and methods for editing the page including labels of the page’s 3D model. It uses {\tt PageService}, {\tt PageContentService} and {\tt LabelService} to communicate with Model.

Page components are fetched during initialization and sorted. Once sorted, their {\tt compOrder} is set to increment by one (0, 1, 2 .. n) to allow easy manipulation of component order during editing.

3D models get a bit of special treatment because of the need to handle label editing. In current implementation only one 3D model is allowed in a page (if more are present for some reason, only first one is processed).  Thanks to {\tt PageComponent}’s interface, all components are held in a single collection and the same methods are used to manipulate all of them.

During page editing, changes are held in this backing bean and only uploaded to database when saved using {\tt updatePage(…)}, which persists current page and its component collection. Because of this, all editing requests are required to update the page using Ajax; otherwise the view, this bean and all unsaved changes would be reset.

{\tt addComponent(String type)} method is implemented as a switch which pre-fills a default component of given type and places is at the end of collection. Methods for changing component order swap two components in the collection and adjust their {\tt compOrder} appropriately. Components are removed simply by removing them from the collection. No methods for editing the content of individual components are needed, because being managed properties, they can be edited directly in Facelets pages.

A method for persisting changes of 3D model’s labels was implemented. It passes a \glref{JSON} String generated by JavaScript to {\tt LabelService}, where all the magic happens.

\secc ModelController

Note that this takes care of a “Model Manager” page, not displaying models in pages (backing beans are related to a particular view/page rather than Entities). This view scoped backing bean is initialized post-construct and fetches all 3D models from {\tt ModelService} and sorts them alphabetically.

In addition to more standard properties, a {\tt Part modelFile} is bound. It is used to upload files into the system and {\tt Part} is the object generated by Facelets’ upload file component. Methods to upload, edit (meta-data, not geometry) and delete models check user rights and call corresponding service methods. Deletion is preceded by making sure the model is not used in a component.

\secc ImageController

This bean is analogous to {\tt ModelController}, but works with images.

\secc Converters

{\tt ModelConverter} and {\tt ImageConverter} classes implementing {\tt Converter} interface were introduced to allow displaying Models and Images in drop-down lists. Implementation is trivial and maps Entity objects to their IDs.

\sec View -- Facelets and HTML

Since we are creating a web application and using \glref{JSF}, the View is realized by a series of \glref{HTML} (in fact, \glref{XHTML}) pages generated by \glref{JSF}’s presentation technology. In our case, that technology would be Facelets.

Facelets is a page declaration language which can be used for creating templates, \glref{UI} components and much more. It allows effective work with \glref{XHTML} and uses \glref{EL} to access methods and properties of managed beans. It also allows the use of basic conditional statements and iteration though collections. These features are included in several supported tag libraries that need to be included as \glref{XML} namespaces. For more details see \cite[facelets].

\secc Templating

All our pages follow a single basic template located at {\tt webapp/template/basic.xhtml}. A template defines a basic skeleton of the page including interchangeable components placed in their respective locations.

This is an example of inserting our main content component in the template and choosing {\tt welcome.xhtml} as the default component (which is used unless specifically overwritten):

\begtt

<ui:insert name=”content”>
        <ui:include src="../components/welcome.xhtml" />
</ui:insert>

\endtt

And this is how we would use this template in an actual page that uses {\tt content\_page.xhtml} as its main content (assuming other components stay default):

\begtt

<ui:composition template="/template/basic.xhtml">
        <ui:define name=”content”>
                <ui:include src="components/content_page.xhtml"/>
        </ui:define>
</ui:composition>

\endtt

Using such a template lets us reuse components and if the defaults are set correctly, we only need to define one or two components per page. This practice reduces writing a new page into writing a content component. It makes the pages easily maintainable, as changing a component affects all pages that are using it without disturbing the rest of the layout.

\secc Page URLs

Pages are accessed at \glref{URL}s matching their name appended to the server’s root \glref{URL}. At a local server running on GlassFish’s default port, the {\tt index.xhmtl} page would then be accessible at {\tt http://localhost:8080/index.xhtml}.

However, all pages (or categories) are using a common {\tt page.xhtml} webpage. To differentiate between individual content pages, an ID attribute is added to the \glref{URL}. A page with ID = 1 would be accessible at {\tt http://localhost:8080/page.xhtml?id=1}. \glref{URL} IDs match database IDs of pages/categories.

This makes the pages bookmarkable and easy to navigate from server’s point of view, but it does not look very pretty. In the future, a library such as PrettyFaces \cite[prettyfaces] might be used to rewrite \glref{URL}s.

\secc Style -- CSS

Pages are styled using a combination of a basic style sheet {\tt basic.css} and an additional sheet specific for the page, such as {\tt category.css}. Components generated by JavaScript are styled inside JavaScript.

Although the style is not overly complex, \glref{CSS} presented me with a lot of issues regarding absolute/relative positioning, alignment and sometimes browser compatibility. The final style should be compatible with all major browsers and provide scalability within reasonable limits.

\secc Ajax

Some pages are using \glref{Ajax} to update only their necessary parts instead of reloading the whole page. Thankfully Facelets provides a {\tt f:ajax} tag which is easy to use.

Unfortunately, this particular \glref{JSF} build is suffering from an issue where view state is not retrieved upon \glref{Ajax} calls. This resulted in losing page/component IDs (\glref{URL} parameters) upon consequent \glref{Ajax} calls. This was fixed by appending a JavaScript file which adds missing hidden {\tt ViewState} fields to forms (see \cite[ajaxfix] for details).

\secc Localization

{\tt LanguageController} is responsible for choosing the current locale. There are two levels of localization in the application:

\begitems

*{\bf Localized content} is realized in Model layer by Entities representing localized data.

*{\bf Localized UI} is realized by inserting localized strings from a property file. Property files such as {\tt WebStrings\_en.properties} contain key-value pairs of strings for the \glref{UI}. They are registered as named resource bundles in {\tt faces-config.xml} so that they can be easily accessed in \glref{EL} expressions.

\enditems


\secc Language Component -- Example Component

{\tt language\_bar.xhtml} displays flags for changing languages in all pages and is backed by {\tt languageController}. 

All available languages are taken from {\tt languageController.supportedLanguages}.

Following Facelets snippet demonstrates how a template component is defined ({\tt ui:component}), how \glref{HTML} components can be defined using Facelets tags ({\tt h:panelGroup}) or plain \glref{XHTML} tags ({\tt div}), how backing bean data is accessed ({\tt value=…}), how basic iteration through a collection is done ({\tt ui:repeat}), how action methods are invoked ({\tt action=…}) and how images are inserted ({\tt h:graphicImage}):

\begtt

<ui:component>
  <h:panelGroup>
    <ui:repeat var="lang"
        value="#{languageController.supportedLanguages}">                    
      <h:form>
        <div class="flagDiv">
          <h:commandLink
              action="#{languageController.switchLanguage(lang)}">
            <h:graphicImage
                alt="#{lang.name}" title="#{lang.name}"
                library="images" name="flags/#{lang.flagFile}" />
          </h:commandLink>
        </div>
      </h:form>
    </ui:repeat>
  </h:panelGroup>
</ui:component>

\endtt

\secc Other Common Components

Unless stated otherwise, these components are displayed in all pages and do not have a designated backing bean.

\begitems

*{\tt login\_bar.xhtml} provides typical login fields and buttons and is backed by {\tt loginController}. There are two alternate forms, one for login and one for users who are already logged. This is implemented by setting the {\tt rendered} attribute of each form to {\tt loginController.logged} or its negation.

*{\tt logo.xhtml} displays the main logo, which is also a link to the index page.

*{\tt horizontal\_menu.xhtml} displays buttons leading to Model Manager and Image Manager. It is only visible when an editor is logged in. It does not have its own backing bean, but checks {\tt loginController} for current user’s role.

*{\tt search\_bar.xhtml} provides a search field and submit button. It does not use a backing bean, just redirects to {\tt search.xhtml} with input as \glref{URL} parameter.

*{\tt messages.xhtml} displays messages and warnings which are not paired with any particular UI component. In other words, this is the default place where messages are displayed.

*{\tt path.xhtml} displays a path to current page, which is a series of links to higher categories for easier navigation. It is used in category and content pages and {\tt pathController} is its backing bean.

*{\tt footer.xhtml} contains a simple copyright note and a link to “Help” page.

\enditems

\secc Page Specific Components

\begitems

*{\tt category.xhtml} is a component representing “content” when browsing categories. It is backed by {\tt categoryController}. Some extra buttons are shown to editors, so it also uses {\tt loginController} to check current user’s role.

It displays general information about current category and iterates though two lists of items: subcategories and pages. Both types of items are generated by a subcomponent {\tt category\_item.xhtml}, which creates a clickable visual representation of a subcategory or page.

*{\tt search\_results.xhtml} is a component displaying search results (pages matching a search query). It is backed by {\tt searchController} and shows a list of pages similar to the “pages” section of {\tt category.xhtml}, also using {\tt category\_item.xhtml} subcomponents.

*{\tt content\_page.xhtml} is a component representing actual content, the pages everyone came to see. It is backed by {\tt pageController}.

It displays general information about the page and iterates though all the “page components” using a {\tt content\_component.xhtml} subcomponent. “Page components” currently come in four types:

\begitems

*{\bf Headline} components are rendered as {\tt <h3>} headlines.

*{\bf Text} components are rendered as {\tt <p>} paragraphs.

*{\bf Image} components are rendered as {\tt <image>} images followed by a line of text.

*{\bf Model} components are rendered as an interactive canvas generated in JavaScript (see relevant section) followed by a line of text.

\enditems

*{\tt edit\_content\_page} is a separate editorial interface for pages. This main component provides a static editorial toolbar and editable fields of the page such as name. Current state of the content is shown by iterating {\tt edit\_content\_component} subcomponents, which provide editable fields of related “page components”. These temporary “page components” are not persisted, they only exist in the backing bean and the page is updated by \glref{Ajax} calls. It is of course possible to persist them by clicking a “Save changes” button in the toolbar.

*{\tt models.xhtml} represents Model Manager. It is only accessible to editors and uses {\tt modelController} backing bean.
It provides a form for uploading 3D model files into the system (STL format).

Below that form is a list of existing models, realized by iterating {\tt model\_item.xhtml} subcomponents, which are editable.

*{\tt images.xhtml} represents Image Manager and is analogical to {\tt models.xhtml}.

*{\tt welcome.xhtml} is a simple Home page which displays introductory textual information and a list of root categories (which means it uses {\tt categoryController}).

*{\tt help.xhtml} is a Help page which displays a short user guide.

\enditems

\sec Model Viewer

The model viewer runs in the client browser rather than the server and is written in JavaScript. The script can be found in {\tt view3d.js}.

{\tt three.js} graphical library \cite[threejs] was used, as well as some of its “example” classes, namely {\tt STLLoader.js}, {\tt TrackballControls.js} and {\tt Detector.js}.

\secc Basics, Rendering

Typical {\tt three.js} applications work with a {\tt Scene} which holds a {\tt Camera} and other 3D objects. They then use a {\tt Renderer} to display the {\tt Camera}’s “view” onto a {\tt Canvas} \glref{DOM} element in an \glref{HTML} page.

There are several {\tt Renderer}s available, most notable being {\tt WebGLRenderer}, which uses the \glref{WebGL} technology to allow hardware acceleration. The alternative {\tt CanvasRenderer} works without using \glref{WebGL} and provides wider support at the cost of performance. \glref{WebGL} is clearly superior, but we enable {\tt CanvasRenderer} as a “fallback” option when no \glref{WebGL} is available in client browser (detected by {\tt Detector.js}). A warning message is displayed though, as {\tt CanvasRenderer} cannot be expected to work properly.

A typical scene is statically initialized and then animated in a rendering loop. An inefficient way to do this is to call the rendering function every few milliseconds. A more efficient way is using the {\tt requestAnimationFrame} \glref{API}, which lets the browser handle rendering calls, synchronizing redraws of multiple animations and stopping the loop when the scene is not visible. That is what our application was initially doing. Since our scene includes no automated animation and every motion is triggered by the user, I decided to go one step further and abandoned the render loop altogether. Instead, the {\tt render} function was added as a listener to controls’ {\tt change} event, only redrawing on user interaction.

\secc Materials and Lighting

{\tt three.js} takes care of illumination and shading as long as lights and materials are set properly.

Mono-colored materials using Lambert’s lighting model were used for shaded surfaces such as the 3D model. For unshaded objects, basic mesh/line materials were used.

The scene is lighted by a weak ambient light and a stronger point light, which is always following the camera (slightly offset up and to the right). This ensures that no part of the model is completely dark (ambient light) but surface unevenness is emphasized by shading (point light).

\label[view3d_models]
\secc 3D Models

The models available to Third Faculty of Medicine come in binary STL format, so naturally that is the first format to be supported.

{\tt three.js} provides a ready-to-use class for loading STL models called {\tt STLLoader}. Using this class, model geometry is loaded as a {\tt BufferGeometry} object for efficient rendering. A {\tt Mesh} object which can be rendered is created using the geometry from {\tt STLLoader} and a custom material. It is then placed in the center of the scene and scaled so that the longest dimension is 100 units.

There are minor problems with the STL format and currently available models: The files are unnecessarily large, shared vertices are treated as separate and no normals are provided. This results in longer loading times and a slightly “polygonal” look, because the lack of normals prevents smooth shading. Recalculating normals is nontrivial because shared vertices would need to be detected every time the model is loaded (moreover, {\tt BufferGeometry} is not easily altered). One of the possible future solutions is the introduction of a more efficient custom file format and a converter from STL files. That way vertices would be merged and normals recalculated once during conversion, rather than every time the model is loaded.

\secc Labels

Labels are stored in the database and sent to the client as JavaScript variables representing an array of {\tt LabelView}s, which have several attributes relevant for displaying them:
\begitems
*Short title, which should be visible in the 3D scene
*Description, which should be displayed on demand
*Location of the relevant point on the bone
*Location of the label tag (ideally where it does not obstruct the model)
\enditems
The application supports several display modes for labels, showing either named tags, blank pins or nothing.

During initialization of the scene, labels’ 3D representation is created based on the input {\tt LabelView}s. In the 3D scene, all labels are children of an {\tt Object3D labelHolder} and each label is represented by an individual {\tt Object3D}. This object stores all the information about the label in custom attributes and has several children, making up the visual representation of each label:

\begitems

*{\bf Sprite}, which is the floating tag with a title. It was originally realized as a {\tt Sprite}, which is a plane always facing the camera. Unfortunately, this approach did not allow picking (see \ref[picking]). The sprites were then remade as simple planes ({\tt Mesh} with {\tt PlaneGeometry}) and their orientation is manually changed in the rendering function so that they always face the camera. This is done by copying the camera’s quaternion.

{\tt three.js} does not support adding text as such, so a texture with the title is generated for each label. For this purpose a {\tt Canvas} is created, length of title is calculated, then the canvas is stretched to fit the title, a semitransparent rounded rectangle of appropriate size is drawn on the canvas (rest is transparent) and the title is printed. A texture is created from the canvas and mapped onto the plane geometry.

*{\bf Pin}, which is a simple ball replacing the sprite in one of the modes. They share the location with sprites and are never displayed at the same time as sprites. This is simply a {\tt Mesh} with {\tt SphereGeometry} and a simple material.

*{\bf Point}, which marks the relevant point on the model’s surface. It is a small {\tt Mesh} with {\tt SphereGeometry} and a red, unshaded material.

*{\bf Line}, which connects the point and sprite. It is red at the starting point and fades into background color near the sprite to be less obtrusive. It would look better to fade into transparency, but that would require a custom shader, which is a lot of effort for such a small improvement.

\enditems

\label[picking]
\secc Label Selection

Labels are selected by picking, which is a method of interaction letting the user select objects in the 3D scene. In our application, it is realized by {\tt three.js}’s {\tt Projector} and {\tt RayCaster}, which can create a ray starting at a point on the screen and going straight “through”. Intersections of the ray and 3D objects in the scene can be retrieved.

It is important to carefully map screen coordinates to viewport coordinates because the viewport (canvas) can be located anywhere on the screen due to other content, scrolling or zooming. The converted coordinates should be in {\tt<-1; 1>} range. It is also important to note that the vertical coordinate needs to be inverted. Following snippet shows correct conversion:

\begtt
mouse.x = ((event.clientX -
    renderer.domElement.getBoundingClientRect().left) / width) * 2 - 1;
mouse.y = - ((event.clientY -
    renderer.domElement.getBoundingClientRect().top) / height) * 2 + 1;
\endtt

The ray can be created using {\tt Projector}'s {\tt unprojectVector(…)}, which helps us transform viewport coordinates into world coordinates. We use the ray to construct a {\tt RayCaster}, whose {\tt intersectObjects(…)} method returns all intersections including location and object which was hit.

For label picking, we are checking if any visible parts of labels were intersected. If so, {\tt selectLabel(label)} function is called. Previously selected label is unselected and this one is selected. In case this label was previously selected, it is simply unselected. A selected label is marked by a different color sprite and its description is shown in a special text field (see \ref[view3d_ui]).

\secc Camera Controls

Camera position can be changed by user. Unlike some other graphical libraries, {\tt three.js} changes view by actually manipulating the camera rather than the entire world.

To handle user interaction with the camera, {\tt TrackballControls.js} class was used. Originally {\tt OrbitControls.js} was used, but users objected to orbit’s slightly constrained movement (vertical limit to +/-90 deg.). The natural replacement was trackball, which allows free rotation around all axes.

Trackball allows three types of view manipulation, while the camera is always looking at current target point:

\begitems
*{Rotation} uses an imaginary “trackball”, a sphere centered in current target point. When user drags the left mouse button, camera orbits the target and the scene reacts as if the user grabbed a point on the trackball and rotated the trackball around its center.
*{Panning} is activated by dragging the right mouse button and it moves the camera without changing its rotation, which means the target point is also moved. The translation of both camera and target is perpendicular to camera direction.
*{Zooming} is activated by mouse wheel and it changes the camera’s “orbit radius”, or simply put the distance between camera and target. 
\enditems

The {\tt TrackballControls} class was slightly altered to fire {\tt change} events on mouse movement and only propagate the original event when we want to (so that the page does not scroll when we zoom).

Current controls work well with a mouse. They also support touch devices and basic one/two finger gestures. However, some additional tweaking might be necessary in order to intuitively combine 3D controls with default web controls on mobile devices (e.g. 3D zoom vs. page zoom).

\label[view3d_ui]
\secc UI Components

Not everything we need to display is a part of the 3D scene. Certain elements such as buttons and select boxes create the 2D \glref{UI} which does not change position when the camera moves.

They are created and updated in JavaScript by manipulating the page’s \glref{DOM}. The biggest issue is their placement, which needs to be recalculated on resize.

These UI components include: 

\begitems
*A box which displays selected label’s description (or default text if unselected)
*A select box which allows users to switch label display mode
*A “loading” sign which is displayed until {\tt STLLoader}’s {\tt load} event is fired
*Buttons related to label editing, which are only displayed to authenticated editors
\enditems

\secc Window Resize

It is important to properly handle window resize and to initialize the canvas correctly depending on window size (we call our {\tt onWindowResize()} function during initialization too).

The size of the containing element (a {\tt div}) is determined by the page’s \glref{CSS}.

On resize we need to set the size of our renderer to fit into the {\tt div}’s width, decide on a reasonable height (4:3 ratio by default, but never higher than window), change the camera’s aspect and update its projection matrix.

Then we need to position all \glref{UI} components appropriately. Because of issues related to positioning and picking, the containing element’s position is set as {\tt static}. That prevents us from using relative positioning for \glref{UI} components. This leads to all \glref{UI} components being placed absolutely, their position and dimensions calculated from {\tt container.offsetLeft}, {\tt  container.offsetTop} and renderer’s {\tt width} and {\tt height}.

Lastly, the controls are updated so that the “trackball” is centered correctly.

After this setup the scene is rendered to reflect the changes.

\label[view3d_edit]
\secc Editing

The script also includes everything needed for editing the labels. Following components and features are available when an editor is logged in:

\begitems
 *{\bf Save changes} button, which creates a \glref{JSON} string representing an array of {\tt LabelView}s of changed labels and submits it to server.
*{\bf New label} button, which enables the editor to select a point on bone’s surface (see picking in \ref[picking], except we intersect the model). From that point a new default label (default text, set distance of tag from surface, perpendicular to surface) is created and selected.
*The box with label description is made {\bf editable}, so that upon selection two editable fields (title and description) are dynamically created and their {\tt oninput} events alter the label’s content. Changing the title also redraws the label’s texture in real time. A {\bf Delete} button is appended to the box, letting the editor remove selected label.
*Label {\bf sprites can be dragged} when selected. The translation is perpendicular to camera direction and realized by intersecting (see picking in \ref[picking]) a large invisible plane facing the camera and placed where the sprite is placed. Theoretically just intersecting the sprite should be enough, but in practice users can drag faster than the application reacts and “lose grip” of the sprite when they quickly move their cursor out of it. The line connecting label's point and sprite needs to be recreated.
\enditems

Labels include a {\tt needsUpdate} flag to determine if they need to be submitted to server. To further specify the action, {\tt isNew} and {\tt isDeleted} flags were introduced. This means that labels deleted in current editorial session are not in fact removed from the scene, just made invisible and marked for deletion so that we know what to delete when changes are submitted.

\secc Mouse Mode and Mouse Events

{\tt TrackballControls} take care of their events, but we still need to listen to mouse events because of picking and editing.

Three custom mouse modes are used:
\begitems
*{\tt view} only enables label selection
*{\tt moveSprite} allows the sprites to be dragged
*{\tt addLabel} allows selection of a point for new label
\enditems

And three mouse events are processed:
\begitems
*{\tt mousedown} checks if a label was hit and if it was, it remembers which one. If a sprite was hit and an editor is logged in, mouse mode is switched to {\tt moveSprite}.
*{\tt mousemove} is mostly needed in {\tt moveSprite} mode (see \ref[view3d_edit]), but also displays a marker at intersection point in {\tt addLabel} mode.
*{\tt mouseup} checks what was hit and reacts depending on current mode:
\begitems
*{\tt view}: If the same label was hit in {\tt mousedown}, it is selected.
*{\tt moveSprite}: Mode is switched back to {\tt view}.
*{\tt addLabel}: If model was hit, new default label is created (see \ref[view3d_edit]).
\enditems
\enditems

\secc Using the Script, Required Variables

To use the {\tt view3d.js} script in a \glref{HTML} page, two basic requirements must be met.

All required libraries/classes must be included before this script is run: 
\begitems
*{\tt three.js} or {\tt three.min.js}
*{\tt Detector.js}
*{\tt STLLoader.js}
*{\tt TrackballControls.js}
\enditems

Several variables need to be set before this script is run:
\begitems
*{\tt editable} determines whether editor mode is enabled.
*{\tt modelPath} leads to the 3D model file to be displayed.
*{\tt strings} is an object containing key-value pairs of localized UI strings.
*{\tt labels} is an array containing localized labels in {\tt LabelView} format.
*{\tt labelUpdateInput} and {\tt labelUpdateButton} are (invisible) DOM elements used to input and submit label updates. They are bound to backing beans, so they cannot be created inside the script.
\enditems

\label[atlasfiller]
\sec Data Transfer

Previous version of the Atlas contained models and labels which are still relevant in our application as well as a hierarchy of categories which can be used.

I created a Java application called AtlasFiller for the sole purpose of transferring this data on a one-time basis.

Given correct paths, it parses all relevant XML files taken from the old Atlas and creates a hierarchy of data objects representing categories, pages and labels. This representation is then inserted into our application’s database as the currently used structures: A set of {\tt Model}s and their {\tt Label}s, a tree of {\tt Category}s and {\tt Page}s, each page having one {\tt ModelComponent} with the related {\tt Model}. Localized counterparts of these Entities were created in both Czech and English.

Model files need to be copied to the application’s {\tt …/uploads/models} folder manually.

\sec Deployment

The application was deployed to a production server belonging to Third Faculty of Medicine in December 2014 under the name {\bf Skelet 3D}. A virtual machine running Debian \glref{OS} was created specifically for our application.

To match the conditions used during development, a GlassFish 4.1 server was installed and its pre-included Java \glref{DB} database was setup as well as proper connection pools (using GlassFish’s Administration Console). It is worth noting that Java \glref{DB} does not start automatically with the server and needs to be started manually from the command line.

Database tables were created remotely using the \glref{SQL} script from early implementation stages (see \ref[impl_tables]) and populated with basic data such as {\tt Language}s and example user accounts.

Data from previous version were remotely imported using the AtlasFiller application (see \ref[atlasfiller]).

Storage for uploaded files was setup at {\tt /home/glassfish/atlas-webapp/uploads/} and existing models were transferred manually.

The application itself could not be deployed using NetBeans for unknown reasons, so the \glref{WAR} file was deployed manually using GlassFish’s Administration Console.

Daily backup of the database as well as uploaded files was setup to prevent loss of data.

The application is currently running on this server at http://195.113.62.79/, also replacing the previous version of Atlas on the domain name http://skelet3d.lf3.cuni.cz/ \cite[1].


\sec Documentation

\begitems
*A short, basic user guide is available on the “Help” page directly on the website.
*A thorough editor’s guide was created and was given to current editors. It can be seen on attached CD.
*JavaDoc documentation for public \glref{API}s was generated from source code’s comments. It can be seen on attached CD.
\enditems

