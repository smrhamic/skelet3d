Implementation was done in NetBeans IDE 8.0.1 \cite[netbeans], a free open source development environment mostly focused on Java.

For development purposes, a local Glassfish 4.1 server was installed and integrated into NetBeans for easy “on save” deployment in real time.

\sec Data Model

The first step of implementation was creating a data model. As mentioned in previous chapter, our business objects will be persisted in a relational database. Images and models will also be using a file system to save their possibly large binary data.

\secc Setting Up a Local Database

Glassfish server comes with a pre-installed Java DB and NetBeans made it easy to setup a connection.

The only pitfall lay in Java’s default security policy, which did not allow access to Java DB on standard port 1527. See StackOverflow question \cite[so_java_permits] for details.

\secc Creating Tables

I used the ER diagram from design phase to generate an SQL script for table creation. I had to make syntactic changes because generated script was in MySQL, which differs from Java DB syntax. After solving all syntactic issues, all tables were successfully created. The working script was saved for later use.

\secc Generating Entities

NetBeans offers a feature for generating Entity classes from a registered database. I gladly used this feature to generate properly annotated, JPA-compatible classes for all Entities.

In later stages of development, Entities returned to being thin data-holding classes without much logic of their own. Other than several simple changes (see below) and removing a small amount of generated ballast, they were largely the same as the originally generated ones.

\secc PageComponent Abstract Class

Page components, namely {\tt HeadlineComponent}, {\tt TextComponent}, {\tt ImageComponent} and {\tt ModelComponent} share 
this common ancestror.

It implements {\tt Comparable<PageComponent>} and a {\tt compareTo(PageComponent c)} method which sorts components by their order. It also defines an abstract getter and setter for {\tt compOrder} and a getter for {\tt componentType}, which is to return a string representation of component type such as “text” or “image”.

\sec Service Layer

Services are in charge of business logic, in case of our Atlas mostly handling persistence and relations between business objects. All service classes are EJBs to allow container-managed transactions. This is important, because otherwise all transactions need to be handled manually and JPA {\tt EntityManager} cannot be simply injected.

\secc BasicService

All service classes inherit from this common ancestor. It is a generic class {\tt BasicService<E, PK>} where {\tt E} is an Entity class and PK is the primary key class of the Entity.

It injects an {\tt EntityManager} using the {\tt @PersistenceContext} annotation, leaving it to the descendant services to make sure this injection is possible (simply being EJB fulfills this requirement) or creating their own {\tt EntityManager}.

It provides a {\tt BasicService(Class<E> entityType)} constructor, which takes the Entity class as a parameter. This might seem unnecessary when using generic classes, but I found no better way to access the Entity’s type in method calls other than keeping a {\tt type : Class<E>} property and assigning it explicitly in the constructor.

{\tt BasicService} implements 5 default CRUD methods:

\begitems

*{\tt find(PK key) : E}

finds an Entity by its primary key, using {\tt EntityManager}’s {\tt find(…)} method.

*{\tt findAll() : List<E>}

finds all Entities of a type {E} using a simple JPQL query on {\tt EntityManager}.

*{\tt save(E entity)}

persist a previously unpersisted Entity using {\tt EntityManager}’s {\tt persist(…)} method.

*{\tt update(E entity)}

updates a persisted Entity using {\tt EntityManager}’s {\tt merge(…)} method.

*{\tt delete(E entity)}

deletes a persisted Entity using {\tt EntityManager}’s {\tt remove(…)} method. In order for the deletion to work, it first needs to get a managed instance of the entity by referencing the output of {\tt merge(entity)}.

\enditems

\secc Common Traits and LanguageService Example

The inheriting services implement different methods, but follow certain similar patterns. They are {\tt @Stateless} EJBs, they are related to an Entity class and have a no-argument constructor which calls {\tt BasicService(entityType)}.

Below you can see the actual code of {\tt LanguageService}, one of the simplest service classes in our application. Note how it extends {\tt BasicService}, calls its super-class’s constructor and uses inherited {\tt Entity Manager em} to perform operations related to persistence (in this case it executes “find” queries). Other methods such as {\tt findAll()} or {\tt save(Language lang)} are inherited from {\tt BasicService} and not overridden, since their default implementation is sufficient for {\tt Language}.

\vfil \break

\begtt

@Stateless
public class LanguageService extends BasicService<Language, Integer> {

    /**
     * Constructs a LanguageService.
     */
    public LanguageService() {
        super(Language.class);
    }
    
    /**
     * Finds the default persisted Language.
     *
     * @return First result of a "default" flagged Language; or null.
     */
    public Language findDefaultLanguage() {
        // get default flagged language
        try {
            TypedQuery<Language> query = em.createQuery(
                    "SELECT l FROM Language l "
                            + "WHERE l.defaultLang = TRUE",
                    Language.class);
            return query.getSingleResult();
        } catch (NoResultException e) {
            // if none, null
            return null;
        }
    }
    
    /**
     * Finds persisted Language by ISO short code.
     *
     * @param code ISO code to search for. Examples: "en", "cs"
     * @return Language matching the ISO code, null if no match.
     */
    public Language findLanguageByISO639(String code) {
        // get language with matching code
        try {
            TypedQuery<Language> query = em.createQuery(
                    "SELECT l FROM Language l "
                            + "WHERE l.short1 = :code",
                    Language.class);
            return query.setParameter("code", code).getSingleResult();
        } catch (NoResultException e) {
            // if none, null
            return null;
        }
    }
}
\endtt

\vfil \break

\secc UserService

\begitems

*{\tt login(String login, String pass) : User}

Validates login credentials, uses a JPQL query and either returns a matching user or {\tt null}.

\enditems

Unfortunately, advanced user management is not implemented as of yet. One of the next steps is making the stored passwords safer by hashing them with salt. The database was created with this in mind, so the implementation should be easy.

\secc CategoryService

\begitems

*{\tt findRootCategories() : List<Category>}

Uses a JPQL query which returns all categories without a parent (top-level categories).

*{\tt createCategoryView(Category cat, Language lang) : CategoryView}

Creates a {\tt CategoryView} based on {\tt cat} argument and queried {\tt CategoryInfo}. It also calculates the number of pages.

*{\tt countNumberOfPages(Category cat, Language lang, boolean publishedOnly) : int}

Recursively counts the number of pages inside category and its child categories. The recursion can be costly, but this will hopefully prove insignificant due to a low number of categories in the tree. If this ever becomes an issue, the solution is keeping a “numPages” property in the database. This would mean updating all ancestor categories whenever a page is created / removed, but it would speed up regular browsing. It is worth noting that thanks to JPA, this recursion accesses objects in memory and does not cause database hits.

\enditems

\secc PageService

\begitems

*{\tt createNewPage(int categoryId) : Page}

Creates a blank, unpublished {\tt Page} including {\tt PageContent}s for all language variants. Persists all this and also updates the parent category to recognize the new page.

*{\tt createPageView(Page page, Language lang) : PageView}

Creates a {\tt PageView} based on {\tt page} argument and queried {\tt PageContent}.

\enditems

It is also worth noting that this service overrides {\tt delete(page)} and updates the parent category’s page collection, which would otherwise still include a reference to the deleted page.

\secc PageContentService

\begitems

*{\tt updateWithComponents(pageContent, List<PageComponent> components)}

Replaces all {\tt PageComponent}s with new ones (passed in argument). Iterates through the {\tt components} collection and adds each component to {\tt PageContent}’s respective collection (text, image…). Changes are persisted using inherited {\tt update(pageContent)}.

\enditems

\secc ModelService

\begitems

*{\tt uploadModel(String name, Part modelFile)}

Creates and persists a {\tt Model} entity and also saves the uploaded file to server. The filename is taken from uploaded file, but non-standard characters are replaced and in case of duplicity, numbers are appended. Models are persisted in a designated folder which the server recognizes as an “alternate document root” for easy access on the website.

*{\tt deleteModel(Model model)}

Calls the default {\tt delete(model)} and also deletes the model’s binary file.

*{\tt isUsed(Model model) : boolean}

Runs a JPQL query to find out whether this model is used in any component.

\enditems

\secc ImageService

Works very much like {\tt ModelService} but with {\tt Image} entities and image files.

\secc LabelService

\begitems

*{\tt createLabelViews(Model model, Language lang) : List<LabelView>}

Creates all {\tt LabelView}s for a model in given language using a JPQL query. JPQL lets us create instances of any class if we map the query results to a constructor. That feature was used here so that the “JOIN” query returns a list of {\tt LabelView}s directly.

*{\tt updateLabelsFromJSON(String json, Model model, Language lang)}

Labels are edited in client side JavaScript and changes to be saved are sent to the server as a JSON string. The string represents an array of {\tt LabelViews}. This method parses the string using Google’s open source library GSON \cite[gson]. Then it treats each {\tt LabelView} appropriately to its {\tt action} property and either creates, deletes or removes a {\tt Label} including its {\tt LabelContent}. {\it  Note: It could be argued that the conversion from JSON to LabelView objects should be done in Controller rather than the Service layer.}

\enditems

\secc LabelContentService

This service does not implement any new methods, but overrides {\tt save(labelContent)} and {\tt update(labelContent)} to escape all textual data before persisting. This is necessary, because labels are displayed in JavaScript, which easily breaks if unsafe characters are present.  This is achieved by {\tt StringEscapeUtils.escapeJavaScript(text)}, which is a method of the Apache Commons Lang \cite[apache_commons] library.

\sec Backing Beans

Backing beans are the next layer of our application, one step closer to the client. In our application they are called Controllers (although the real Controller is in fact a {\tt FacesServlet} working behind the scenes).

Each backing bean belongs to a View component (a reusable piece of HTML), provides content from the Model and methods for manipulating it.

Backing beans are annotated with their “scope”, which defines the bean’s lifespan. Most beans are either {\tt @ViewScoped}, which means they’re recreated when a new page is displayed, or {\tt @SessionScoped}, which means the bean lives and holds its state as long as a session with a client is maintained.

\secc BasicController

This is an abstract class which backing beans can inherit from.

Backing beans do not have too much in common, so this ancestor is not really necessary. It was introduced in later stages of development to make the other backing beans’ code a little neater and easier to read.

It implements methods for displaying messages in the View. Messages are passed as a string argument and set as {\tt FacesMessage} in current {\tt FacesContext}. Because the messages can be (and typically will be) localized strings from a resource bundle, these methods evaluate their string input as an EL expression. That way, simple strings are displayed directly, but EL expressions can be used just like they would be used in a Facelets page.

Displaying messages is a common task especially during content editing. This originally created chunks of repeated, verbose code. Implementing a common ancestor reduced these chunks to one-line method calls, which look like this for localized messages:

 {\tt showWarning(\char`\"\#\char`\{messages.noRights\char`\}\char`\")}.

